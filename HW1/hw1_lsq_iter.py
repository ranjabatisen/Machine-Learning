# -*- coding: utf-8 -*-
"""hw1_lsq_iter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aYhR8Mrn6de_sKpQdDO_LA9FWANJFDjt
"""

import matplotlib.pyplot as plt
import numpy as np

# Closed form
def lsq(A,b):
    # Finding Moore-Penrose Pseudoinverse of matrix A
    A_pseudoinverse = np.linalg.pinv(A)
    # Calculating value of w using closed form
    w_cap = np.dot(A_pseudoinverse,b)
    return w_cap

# Richardson algorithm
def lsq_iter(A,b):
    A_norm = np.linalg.norm(A)
    # Finding \mu
    param= 1/np.square(A_norm)
    # Intializing w^(1) = 0
    w_k = np.zeros((10,1))
    Wk = []
    # Calculating w^(k) for each iteration
    for i in range(500):
        w_k = w_k - np.dot(np.dot(param,A.T),(np.dot(A,w_k)-b))
        Wk.append(w_k)
    return(Wk)

def main():
    # Generating a random matrix A
    A = np.random.rand(20,10)
    # Generating a vector b
    b = np.random.rand(20,1)
    # Solving w by closed form
    w_cap = lsq(A,b)
    # Solving w by Richardson algorithm
    w_k = lsq_iter(A,b)
    # Storing value of ||w^k - w_cap|| for every iteration
    difference = []
    for i in range(500):
        diff = np.square(np.linalg.norm(w_k[i] - w_cap))
        difference.append(diff)
    # Plotting the convergence of ||w^k - w_cap||
    plt.plot(difference)
    plt.xlabel('No. of iterations')
    plt.ylabel('Difference')
    plt.title('Convergence plot for Richardson algorithm')
    plt.show()

if __name__== "__main__":
    main()